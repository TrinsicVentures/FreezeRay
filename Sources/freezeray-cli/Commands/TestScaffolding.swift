import Foundation

/// Helper struct for test scaffolding operations
/// Extracted from FreezeCommand to enable unit testing
public struct TestScaffolding {

    public init() {}

    /// Result of scaffolding operation
    public struct ScaffoldResult {
        public let fileName: String
        public let created: Bool  // true if created, false if already existed

        public init(fileName: String, created: Bool) {
            self.fileName = fileName
            self.created = created
        }
    }

    /// Scaffolds a drift test file for a schema version
    /// Only creates the file if it doesn't already exist (user-owned)
    public func scaffoldDriftTest(
        testsDir: URL,
        schemaType: String,
        appTarget: String,
        version: String
    ) throws -> ScaffoldResult {
        let versionSafe = version.replacingOccurrences(of: ".", with: "_")
        let fileName = "\(schemaType)_DriftTests.swift"
        let filePath = testsDir.appendingPathComponent(fileName)

        // Skip if file already exists (user-owned, never overwrite)
        if FileManager.default.fileExists(atPath: filePath.path) {
            return ScaffoldResult(fileName: fileName, created: false)
        }

        let testContent = """
        // AUTO-GENERATED by FreezeRay CLI
        // This file is scaffolded once and owned by you. Customize as needed.
        //
        // Purpose: Verify that the frozen schema v\(version) hasn't drifted
        // Generated by: freezeray freeze \(version)

        import Testing
        import FreezeRay
        @testable import \(appTarget)

        /// Drift test for \(schemaType) v\(version)
        ///
        /// This test verifies that the current schema definition matches the frozen fixture.
        /// If this test fails, it means the schema has been modified since it was frozen.
        @Test("\(schemaType) v\(version) has not drifted")
        func test\(schemaType)_\(versionSafe)_Drift() throws {
            // Call the macro-generated check function
            try \(schemaType).__freezeray_check_\(versionSafe)()

            // TODO: Add custom data validation here
            // Example:
            // - Verify specific model properties exist
            // - Check relationship configurations
            // - Validate index definitions
        }

        """

        try testContent.write(to: filePath, atomically: true, encoding: .utf8)

        return ScaffoldResult(fileName: fileName, created: true)
    }

    /// Scaffolds a migration test file for upgrading from one version to another
    /// Only creates the file if it doesn't already exist (user-owned)
    public func scaffoldMigrationTest(
        testsDir: URL,
        migrationPlan: String,
        fromVersion: String,
        toVersion: String,
        appTarget: String
    ) throws -> ScaffoldResult {
        let fromSafe = fromVersion.replacingOccurrences(of: ".", with: "_")
        let toSafe = toVersion.replacingOccurrences(of: ".", with: "_")
        let fileName = "MigrateV\(fromSafe)toV\(toSafe)_Tests.swift"
        let filePath = testsDir.appendingPathComponent(fileName)

        // Skip if file already exists (user-owned, never overwrite)
        if FileManager.default.fileExists(atPath: filePath.path) {
            return ScaffoldResult(fileName: fileName, created: false)
        }

        let testContent = """
        // AUTO-GENERATED by FreezeRay CLI
        // This file is scaffolded once and owned by you. Customize as needed.
        //
        // Purpose: Test migration from v\(fromVersion) → v\(toVersion)
        // Generated by: freezeray freeze \(toVersion)

        import Testing
        import FreezeRay
        @testable import \(appTarget)

        /// Migration test from v\(fromVersion) → v\(toVersion)
        ///
        /// This test verifies that the migration path between these versions works correctly.
        @Test("Migrate v\(fromVersion) → v\(toVersion)")
        func testMigrateV\(fromSafe)toV\(toSafe)() throws {
            // Call the macro-generated per-version migration function
            try \(migrationPlan).__freezeray_test_migrate_\(fromSafe)_to_\(toSafe)()

            // TODO: Add data integrity checks here
            // Example:
            // - Verify data is preserved during migration
            // - Check that new fields have default values
            // - Validate relationship updates
            // - Ensure no data loss for critical fields
        }

        """

        try testContent.write(to: filePath, atomically: true, encoding: .utf8)

        return ScaffoldResult(fileName: fileName, created: true)
    }

    /// Finds the previous version by scanning the Fixtures directory
    /// Returns nil if no previous version exists (this is the first schema)
    public func findPreviousVersion(current: String, fixturesDir: URL) -> String? {
        guard FileManager.default.fileExists(atPath: fixturesDir.path) else {
            return nil
        }

        guard let contents = try? FileManager.default.contentsOfDirectory(atPath: fixturesDir.path) else {
            return nil
        }

        // Filter out non-version directories and the current version
        let versions = contents.filter { dir in
            dir != current && dir.range(of: #"^\d+\.\d+\.\d+$"#, options: .regularExpression) != nil
        }

        guard !versions.isEmpty else {
            return nil
        }

        // Sort semantically (semantic versioning)
        let sorted = versions.sorted { v1, v2 in
            let c1 = v1.split(separator: ".").compactMap { Int($0) }
            let c2 = v2.split(separator: ".").compactMap { Int($0) }

            for i in 0..<min(c1.count, c2.count) {
                if c1[i] != c2[i] {
                    return c1[i] < c2[i]
                }
            }
            return c1.count < c2.count
        }

        // Return the highest version that's less than current
        let currentComponents = current.split(separator: ".").compactMap { Int($0) }
        for version in sorted.reversed() {
            let versionComponents = version.split(separator: ".").compactMap { Int($0) }

            var isLess = false
            for i in 0..<min(currentComponents.count, versionComponents.count) {
                if versionComponents[i] < currentComponents[i] {
                    isLess = true
                    break
                } else if versionComponents[i] > currentComponents[i] {
                    break
                }
            }

            if isLess {
                return version
            }
        }

        return nil
    }
}
