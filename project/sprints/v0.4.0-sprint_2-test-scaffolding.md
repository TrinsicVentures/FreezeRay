# Sprint 2: Test Scaffolding

**Version:** v0.4.0
**Dates:** TBD
**Status:** ðŸ“‹ Planned

## Goals

When running `freezeray freeze <version>`, automatically scaffold validation tests:
1. **Drift test** - Verifies frozen schema hasn't changed (calls `__freezeray_check_`)
2. **Migration test** - Tests migration from previous version (calls per-version migration functions)

**Key Changes:**
- âœ… `__freezeray_check_` already exists (generated by `@FreezeSchema` macro)
- âŒ Per-version migration functions (`__freezeray_test_migrate_X_to_Y`) **do not exist yet**
- Current: `@TestMigrations` generates one monolithic `__freezeray_test_migrations()` that tests ALL migrations
- Sprint 2: Modify `@TestMigrations` macro to generate individual per-version migration functions
- Sprint 2: CLI scaffolds test files that call these individual functions

## Specification

### Drift Test Scaffolding

**Generated file:** `{SchemaType}_DriftTests.swift`

```swift
import Testing
import FreezeRay
@testable import MyApp

@Test func testAppSchemaV1_0_0_Drift() throws {
    try AppSchemaV1.__freezeray_check_1_0_0()
    // TODO: Add custom data validation
}
```

- **Scaffolded once** - Never regenerated (user owns the file)
- **Skip if exists** - Don't overwrite user customizations
- **TODO markers** - Guide user to add data validation

### Migration Test Scaffolding

**Generated file:** `MigrateV{prev}toV{curr}_Tests.swift`

Example: `MigrateV2_0_0toV3_0_0_Tests.swift`

```swift
import Testing
import FreezeRay
@testable import MyApp

@Test func testMigrateV2_0_0toV3_0_0() throws {
    try AppMigrations.__freezeray_test_migrate_2_0_0_to_3_0_0()
    // TODO: Add data integrity checks
}
```

- **One test file per migration** - V1â†’V2, V2â†’V3, etc.
- **Find previous version** - Scan `FreezeRay/Fixtures/` and sort semantically
- **Skip if exists** - Don't update existing migration tests

## Implementation Plan

### Phase 1: Modify `@TestMigrations` Macro

**Current behavior:**
```swift
@TestMigrations
enum AppMigrations: SchemaMigrationPlan { ... }

// Generates:
static func __freezeray_test_migrations() throws {
    // Tests ALL migrations at once
}
```

**New behavior:**
```swift
@TestMigrations
enum AppMigrations: SchemaMigrationPlan {
    static var schemas: [any VersionedSchema.Type] {
        [AppSchemaV1.self, AppSchemaV2.self, AppSchemaV3.self]
    }
}

// Should generate:
static func __freezeray_test_migrate_1_0_0_to_2_0_0() throws { ... }
static func __freezeray_test_migrate_2_0_0_to_3_0_0() throws { ... }
```

**Challenge:** Macro needs to discover version identifiers from schema types. This requires:
1. Parsing `schemas` array to get schema type names
2. Looking up version from each schema (may require runtime reflection or conventions)

**Alternative approach:** Generate migration functions based on discovered frozen fixtures at runtime, not compile-time.

### Phase 2: CLI Implementation

### 1. Find Previous Version
```swift
func findPreviousVersion(_ current: String) -> String? {
    // Scan FreezeRay/Fixtures/ directories
    // Parse semantic versions (using semver library)
    // Return highest version < current
}
```

### 2. Scaffold Drift Test
```swift
func scaffoldDriftTest(schema: String, version: String) {
    let testFile = "\(schema)_DriftTests.swift"
    guard !FileManager.default.fileExists(atPath: testFile) else { return }
    // Write scaffold with TODO markers
}
```

### 3. Scaffold Migration Test
```swift
func scaffoldMigrationTest(from: String, to: String) {
    let testFile = "MigrateV\(from)toV\(to)_Tests.swift"
    guard !FileManager.default.fileExists(atPath: testFile) else { return }
    // Write scaffold calling __freezeray_test_migrate_X_to_Y()
}
```

## User Workflow

1. Run `freezeray freeze 3.0.0`
2. CLI creates fixtures + scaffolds tests
3. User adds custom assertions to TODO sections
4. User runs `âŒ˜U` in Xcode - tests validate schema
5. User commits tests alongside fixtures

## Design Decisions

See: [ADR-005: Test Scaffolding (Not Generation)](/project/adr/ADR-005-test-scaffolding-not-generation.md)

**Key principle:** Tests are scaffolded once and owned by the user, not auto-generated.

## Success Criteria

**Macro Changes:**
- [ ] `@TestMigrations` generates per-version migration functions (not just monolithic `testAllMigrations()`)
- [ ] Functions named `__freezeray_test_migrate_{from}_to_{to}()` for each schema pair
- [ ] Each function tests migration from one specific version to the next

**CLI Scaffolding:**
- [ ] Drift test scaffolded on first freeze
- [ ] Migration test scaffolded when previous version exists
- [ ] Tests skipped if files already exist
- [ ] TODO markers guide user customization
- [ ] Tests run with `âŒ˜U` in Xcode (no CLI dependency)

## Open Questions

1. **How does macro discover version identifiers?**
   - Option A: Parse `@FreezeSchema(version: "X.Y.Z")` from schemas array (requires AST traversal at macro expansion time)
   - Option B: Convention-based naming (AppSchemaV1 â†’ 1.0.0, AppSchemaV2 â†’ 2.0.0)
   - Option C: Runtime-based approach - macro generates lookup functions, runtime discovers fixtures

2. **Should we keep monolithic `testAllMigrations()` or replace it?**
   - Keep it for convenience (one test runs all migrations)
   - Replace with individual functions only
   - **Recommendation:** Keep both - monolithic for quick smoke test, individual for customization
